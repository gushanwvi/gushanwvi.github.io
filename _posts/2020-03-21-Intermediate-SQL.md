---
layout:     post
title:      Intermediate SQL
subtitle:   Class Notes of Database
date:       2020-03-21
author:     Eric
header-img: bg-202003142141.jpg
catalog: true
tags:
    - Class Notes
    - Database
---



## Join Expressions

* `join......using` (**inner join**)  `inner join` (**inner** is optional)  `natural (inner) join`
  ![](http://q7266277k.bkt.clouddn.com/20200325123004.png)

* `on` 
  * ![](http://q7266277k.bkt.clouddn.com/20200324223657.png)
  
  ![](http://q7266277k.bkt.clouddn.com/20200317223008.png)
  
* `outer join`
  * **left outer join** preserve tuples only in the relation named before the operation
  
  * **right outer join** preserve tuples only in the relation named after the operation
  
  * **full outer join** preserve tuples only in both relations
  
  * compute the inner join and add tuples that do not match any tuple in the other relation(the remaining attributes of the tuple are filled with null values)
  
  * `natural left outer join`
  
  * > Display a list of all students in the Comp. Sci. department, along with the course sections, if any, that they have taken in Spring 2009; all course sections from Spring 2009 must be displayed, even if no student from the Comp. Sci. department has taken the course section.
  
    ![](http://q7266277k.bkt.clouddn.com/20200325113118.png)
  
* `on` vs. `where` 

  * ![](http://q7266277k.bkt.clouddn.com/20200325113845.png)
    the attribute *ID* appears twice in the result
  * ![](http://q7266277k.bkt.clouddn.com/20200325113859.png)
  * The former query includes (70557, Snow, Physics, 0, null, null, null, null, null, null ) < student.ID is 70557 and takes.ID is null >
  * The latter query, every tuple satisfies the join condition true, so no null-padded tuples are generated by the outer join.



## View

#### Definition

* **create view** $v$ **as** < query expression >;
* use ***view name*** just like the ***relation name***
  such as ![](http://q7266277k.bkt.clouddn.com/20200325124402.png)
* Wherever a view relation appears in a query, it is replaced by the stored query expression.



#### Materialized Views

* The view relations are stored and are kept up-to-date. The process of keeping the materialized view up-to-date is called **materialized view maintenance**(or just view maintenance)
* Modifications are generally not permitted on view relations.
* An SQL view is said to be **updatable** if the following conditions are all satisfied by the query defining the view.(that is, inserts, updates or deletes can be applied on the view)
  ![](http://q7266277k.bkt.clouddn.com/20200325130945.png)
* Even with the conditions on updatability, the following problem still remains. Insert the tuple (’25566’, ’Brown’, ’Biology’, 100000) into the *history_instructors* view. This tuple can be inserted into the instructor relation, but it would not appear in the history instructors view since the instructor belongs to the biology department.
* By default, SQL would allow the above update to proceed. However, views can be defined with a **with check option** clause at the end of the view definition; then, if a tuple inserted into the view does not satisfy the view’s **where** clause condition, the insertion is rejected by the database system. Updates are similarly rejected if the new value does not satisfy the **where** clause conditions.



## Transactions

* A **transaction** consist of a sequence of query and/or update statements. 

* The keyword **work** is optional in both the statements.

  ![](http://q7266277k.bkt.clouddn.com/20200325144539.png)

* Once a transaction has executed **commit work**,its effects can no longer be undone by **rollback work**.

* The database provides an abstraction of a transaction as being **atomic**.

* **begin atomic ... end**  :  All the statements between the keywords then form a single transaction.



## Integrity Constraints

* **alter table** *table-name* **add** *constraint*



#### Not Null Constraint

restrict the domain of the attributes

![](http://q7266277k.bkt.clouddn.com/20200325150158.png)



#### Unique Constraint

* **unique** $(A_{j_1},A_{j_2},\dots,A_{j_m})$  
* The **unique** specification says that attributes $A_{j_1},A_{j_2},\dots,A_{j_m}$ form a super key
* However, candidate key attributes are permitted to be null unless they have explicitly been declared to be **not null**. (Because a null value does not equal any other value)



#### Check Clause

* When applied to a relation declaration, the clause **check**(*P*) specifies a predicate *P* that must be satisfied by every tuple in a relation.
  ![](http://q7266277k.bkt.clouddn.com/20200325151617.png)



#### Referential Integrity/Subset Dependencies

* Let r1 and r2 be relations whose set of attributes are R1 and R2, respectively, with primary keys K1 and K2. A subset $\alpha$ of R2 is a foreign key referencing K1 in relation r1
* Unlike foreign-key constraints, in general a referential integrity constraint does not require K1 to be a primary key of r1; as a result, more than one tuple in r1 can have the same value for attributes K1.
* SQL also supports a version of the **references** clause where a list of attributes of the referenced relation can be specified explicitly.
  ![](http://q7266277k.bkt.clouddn.com/20200325175653.png)
* If a delete or update action on the referenced relation violates the constraint, then, instead of rejecting the action, the system can take steps to change the tuple in the referencing relation to restore the constraint.
  * **on delete cascade**
  * **on delete set default**
  * **on delete set null**
  * **on update cascade**
  * **on update set default**
  * **on update set null**



#### Integrity Constraint Violation During a Transaction

* **initially deferred** (added to a constraint specification) : the constraint would then be checked at the end of a transaction, and not at intermediate steps.
* The default behavior is to check constraints immediately.
* A constraint can alternatively be specified as **deferrable**. For constraints declared as deferrable, executing a statement **set constraints** *constraint-list* **deferred** as part of a transaction causes the checking of the specified constraints to be deferred to the end of that transaction.



#### Complex Check Conditions and Assertions

* `check` : check true or false
* An **assertion** is a predicate expressing a condition that the database always satisfies. Domain constraints and referential-integrity constraints are special forms of assertions.
* **create assertion** < assertion-name > **check** < predicate >;
* Since SQL does not provide a `for all X, P(X)` construct (where P is a predicate), we are forced to implement the constraint by an equivalent construct, `not exists X such that not P(X)`, that can be expressed in SQL.
* When an assertion is created, the system tests it for validity. If the assertion is valid, then any future modification to the database is allowed only if it does not cause that assertion to be violated.



## SQL Data Types and Schemas

#### Date and Time Types in SQL

* **date**
* **time**
* **timestamp**
* **interval**
* `cast e as t` (convert a character string *e* to the type *t*, where *t* is one of **date**, **time**, or **timestamp**)
* `extract (field from d)`, where field can be one of **year**, **month**, **day**, **hour**, **minute**, **second**, **timezone_hour** and **timezone_minute**.
* `current_date` returns the current date, `current_time` returns the current time (with time zone), and `localtime` returns the current local time (without time zone).



#### Default Values

![](http://q7266277k.bkt.clouddn.com/20200326091357.png)

![](http://q7266277k.bkt.clouddn.com/20200326091408.png)



#### Index Creation

**create index** *studentID_index* **on** *student(ID)*;



#### Large-Object Types

* character large object : **clob**
* binary large object : **blob**
* ![](http://q7266277k.bkt.clouddn.com/20200326092445.png)



#### User-Defined Types

* SQL provides the notion of **distinct types**. User-defined types are strong types.
* As a result of strong type checking, the expression (department.budget+20) would not be accepted since the attribute and the integer constant 20 have different types. **cast** (*department.budget* **to** *numeric*(12,2)). We could do addition on the numeric type, but to save the result back to an attribute of type Dollars we would have to use another cast expression to convert the type back to Dollars.
* **create type** *Dollars* **as numeric**(12,2) **final**; 
* **create type** *Pounds* **as numeric**(12,2) **final**;
* **drop type**  **alter type**
* ![](http://q7266277k.bkt.clouddn.com/20200326093417.png)



#### Create Table Extensions

* **create table** *temp instructor* **like** *instructor*;
* Store the result of a query as a new table (in some databases the `with data` clause can be omitted)
  ![](http://q7266277k.bkt.clouddn.com/20200326101417.png)

* By default, the names and data types of the columns are inferred from the query result. Names can be explicitly given to the columns by listing the column names after the relation name.



#### Schemas, Catalogs, and Environments

* To identify a relation uniquely, a three-part name may be used, for example, 
  *catalog5.univ_schema.course*
* We can create and drop schemas by means of **create schema** and **drop schema** statements.



## Authorization

#### Granting and Revoking of Privileges

* Each of the types of authorizations is called a **privilege**.
* **select**, **insert**, **update**,and **delete** (short term for all the allowable privileges is **all privileges**)
* A user who creates a new relation is given all privileges on that relation automatically.
* ![](http://q7266277k.bkt.clouddn.com/20200326103918.png)
* **grant update** (*budget*) **on** *department* **to** *Amit, Satoshi*;
  If the list of attributes is omitted, the update privilege will be granted on all attributes of the relation.
* The **insert** privilege may also specify a list of attributes; any inserts to the relation must specify only these attributes, and the system either gives each of the remaining attributes default values (if a default is defined for the attribute) or sets them to *null*.
* Privileges granted to **public** are implicitly granted to all current and future users.
* SQL authorization mechanism grants privileges on an entire relation, or on specified attributes of a relation. However, it does not permit authorizations on specific tuples of a relation.(To permit authorization on specific tuples of a relation we can use authorization on views.)
* ![](http://q7266277k.bkt.clouddn.com/20200326105956.png)
* ![](http://q7266277k.bkt.clouddn.com/20200326110143.png)



#### Roles

* **create role** *instructor*;
* Roles can be granted to users, as well as to other roles.



#### Authorization on Views

* A user who creates a view does not necessarily receive all privileges on that view. She receives only those privileges that provide no additional authorization beyond those that she already had.



#### Authorization on Schemas

* **grant references** (*dept_name*) **on** *department* **to** Mariano;



#### Transfer of Privileges

* By default, a user/role that is granted a privilege is not authorized to grant that privilege to another user/role. If we wish to grant a privilege and to allow the recipient to pass the privilege on to other users, we append the **with grant option** clause to the grant command.
  **grant select on** *department* **to** Amit **with grant option**;
* The creator of an object (relation/view/role) holds all privileges on the object, including the privilege to grant privileges to others.



#### Revoking of Privileges

* **Cascading revocation** : revocation of a privilege from a user/role may cause other users/roles also to lose that privilege. 
* The revoke statement may specify restrict in order to prevent cascading revocation:
  **revoke select on** *department* **from** Amit, Satoshi **restrict**;
* **revoke grant option for select on** *department* **from** Amit;
* Privileges granted by a role
  * Cascading revocation is inappropriate in many situations. SQL permits a privilege to be granted by a role rather than by a user. 
  * By default, the current role associated with a session is null. The current role associated with a session can be set by executing **set role role_name**. The specified role must have been granted to the user, else the **set role** statement fails.
  * To grant a privilege with the grantor set to the current role associated with a session, we can add the clause: **granted by current role** to the grant statement, provided the current role is not null.
